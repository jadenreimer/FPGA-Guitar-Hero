`timescale 1ns / 1ns // `timescale time_unit/time_precision

//define module HEX_Display
module HEX_Display(SW, HEX0);

	//Define input and output buses, which allows us to use ModelSim and the FPGA
	input [3:0]SW;
	output [6:0] HEX0;
	
	//Product of Maxterms
	//We will define every instance of where display bar 0 is NOT Logic 1
	//as a product of sums
	assign HEX0[0] = ~((SW[3] | SW[2] | SW[1] | ~SW[0])
						& (SW[3] | ~SW[2] | SW[1] | SW[0])
						& (~SW[3] | SW[2] | ~SW[1] | ~SW[0])
						& (~SW[3] | ~SW[2] | SW[1] | ~SW[0]));
	
	//Product of Maxterms
	//We will define every instance of where display bar 1 is NOT Logic 1
	//as a product of sums	
	assign HEX0[1] = ~((SW[3] | ~SW[2] | SW[1] | ~SW[0])
						& (SW[3] | ~SW[2] | ~SW[1] | SW[0])
						& (~SW[3] | SW[2] | ~SW[1] | ~SW[0]) 
						& (~SW[3] | ~SW[2] | SW[1] | SW[0]) 
						& (~SW[3] | ~SW[2] | ~SW[1] | SW[0])  
						& (~SW[3] | ~SW[2] | ~SW[1] | ~SW[0]));
	
	//Product of Maxterms
	//We will define every instance of where display bar 2 is NOT Logic 1
	//as a product of sums
	assign HEX0[2] = ~((SW[3] | SW[2] | ~SW[1] | SW[0]) 
						& (~SW[3] | ~SW[2] | SW[1] | SW[0]) 
						& (~SW[3] | ~SW[2] | ~SW[1] | SW[0]) 
						& (~SW[3] | ~SW[2] | ~SW[1] | ~SW[0]));
						
	//Product of Maxterms
	//We will define every instance of where display bar 3 is NOT Logic 1
	//as a product of sums
	assign HEX0[3] = ~((SW[3] | SW[2] | SW[1] | ~SW[0]) 
						& (SW[3] | ~SW[2] | SW[1] | SW[0]) 
						& (SW[3] | ~SW[2] | ~SW[1] | ~SW[0]) 
						& (~SW[3] | SW[2] | ~SW[1] | SW[0]) 
						& (~SW[3] | ~SW[2] | ~SW[1] | ~SW[0]));
						
	//Product of Maxterms
	//We will define every instance of where display bar 4 is NOT Logic 1
	//as a product of sums
	assign HEX0[4] = ~((SW[3] | SW[2] | SW[1] | ~SW[0]) 
						& (SW[3] | SW[2] | ~SW[1] | ~SW[0]) 
						& (SW[3] | ~SW[2] | SW[1] | SW[0]) 
						& (SW[3] | ~SW[2] | SW[1] | ~SW[0]) 
						& (SW[3] | ~SW[2] | ~SW[1] | ~SW[0])  
						& (~SW[3] | SW[2] | SW[1] | ~SW[0]));
	
	//Product of Maxterms
	//We will define every instance of where display bar 5 is NOT Logic 1
	//as a product of sums
	assign HEX0[5] = ~((SW[3] | SW[2] | SW[1] | ~SW[0])
						& (SW[3] | SW[2] | ~SW[1] | SW[0]) 
						& (SW[3] | SW[2] | ~SW[1] | ~SW[0]) 
						& (SW[3] | ~SW[2] | ~SW[1] | ~SW[0]) 
						& (~SW[3] | ~SW[2] | SW[1] | ~SW[0]));
						
	//Product of Maxterms
	//We will define every instance of where display bar 6 is NOT Logic 1
	//as a product of sums
	assign HEX0[6] = ~((SW[3] | SW[2] | SW[1] | SW[0])
						& (SW[3] | SW[2] | SW[1] | ~SW[0]) 
						& (SW[3] | ~SW[2] | ~SW[1] | ~SW[0]) 
						& (~SW[3] | ~SW[2] | SW[1] | SW[0]));
						
endmodule
						